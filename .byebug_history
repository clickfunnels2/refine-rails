c
 I18n.t(".filter.conditions.#{condition.id}.label", default: t(".fields.#{condition.id}.label", label_fallback))
 t(".filter.conditions.#{condition.id}.label", default: t(".fields.#{condition.id}.label", label_fallback))
 t(".filter.conditions.#{condition.id}.label", default: t(".fields.#{condition.id}.label", label_fallback)
condition.display
c
class_name
ENV['NAMESPACE_REFINE_STABILIZERS']
c
input
c
input
c
input
is_relationship_attribute?
s
input
c
s
c
criterion[:input]
c
nodes_to_apply
nodes_to_apply.to_sql
c
input
c
input
c
input
c
input.dig(:filter_refinement)
c
input
c
input
c
criterion[:input]
criterion
get_condition_for_criterion(criterion)
c
criterion
c
s
criterion
index
modified_blueprint
criterion
s
filter.blueprint
c
 filter = Hammerstone.stabilizer_class('Stabilizers::DatabaseStabilizer').new.from_stable_id(id: 2)
 filter = Hammerstone.stabilizer_class('Stabilizers::DatabaseStabilizer').new.from_stable_id(id: filter_id)
class_name
c
'c
Hammerstone.stabilizer_class('Stabilizers::DatabaseStabilizer').new.from_stable_id(id: filter_id)
filter_id
c
Hammerstone::Refine::StoredFilter.count
Hammerstone::Refine::StoredFilter
c
Hammerstone::Refine::StoredFilter.first
c
Hammerstone::Refine::StoredFilter.first
Hammerstone::Refine::StoredFilter.count
c
filter_id
c
s
filter
scope.to_sql
scope
c
Hammerstone::Refine::StoredFilter.count
c
Hammerstone::Refine::StoredFilter.count
Hammerstone::Refine::StoredFilter.all
c
get_options.call.map{|option| option[:id]}
get_options.call.map { |option| option[:id] }.include? select
c
ids
c
ids
c
ids
c
ids
c
cc
c
 single ? values[0] : values
single
single ?
values.select { |value| ids.include? value[:id] }.map! { |value| (value.has_key? :_value) ? call_proc_if_callable(value[:_value]) : value[:id] }
values.select { |value| ids.include? value[:id] }
  values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
get_options.call
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
c
 values = get_options.call.delete_if { |el| el[:id] == nil_option_id }
q
cq
c
q
c
ENV['NAMESPACE_REFINE_STABILIZERS']
class_name
c
 Hammerstone.stabilizer_class('Stabilizers::DatabaseStabilizer')
c
exit
BttUser.where(BttUser.arel_table[:id].not_in(note_select.arel)).to_sql
BttUser.where(BttUser.arel_table[:id].not_in(note_select)).to_sql
note_select.arel
note_select.to_sql
BttUser.where(BttUser.arel_table[:id].not_in(note_select)).to_sql
BttUser.where(BttUser.arel_table[:id].not_in(note_select))
users.project(Arel.star).where(:id).not_in(note_select)
users.project(Arel.star).where(:id).not.in(note_select)
users.project(Arel.star).to_sql
users = BttUser.arel_table
BttUser.where.not(note_select).to_sql
BttUser.where(note_select).to_sql
BttUsers.where(note_select).to_sql
note_select.to_sql
BttUser.where(note_select).to_sql
BttUser.where(note_select)
note_select.to_sql
note_select = BttNote.select(:btt_user_id).where(catalog_id:1)
BttUser.select(:id).where.not(BttNote.select(:btt_user_id).where(catalog_id: 1))
BttUser.select(:id).where.not(BttNote.select(:btt_user_id).where(catalog_id: 1)
BttUser.select(:id).to_sql
 BttNote.select(:btt_user_id).where.not(BttNote.select(:btt_user_id).where(catalog_id: 1))
BttUser.where.not(BttNote.select(:btt_user_id).where(catalog_id: 1))
CatalogEntry.where.not(BttNote.select(:btt_user_id).where(catalog_id: 1))
BttNote.select(:btt_user_id).where(catalog_id: 1).to_sql
BttNote.select(:btt_user_id).where(catalog_id: 1)
BttNote.select(:btt_user_id).to_sql
BttNotes.select(:btt_user_id).to_sql
BttUser.select(:id).where.not(BttNote.select(btt_user_id).joins(:catalogs).where(catalogs: {catalog_id: 1}))
BttUser.select(:id).where.not(BttNote.select(btt_user_id).joins(:catalogs).where(catalogs: {catalog_id: 1})
BttUser.select(:id).where.not(BttNote.select(btt_user_id).where(catalog_id: 1))
BttUser.select(:id).where.not(BttNotes.select(btt_user_id).where(catalog_id: 1))
BttUser.select(:id).to_sql
BttNote.select('True').to_sql
BttNotes.select('True').to_sql
CatalogEntry.select('True').to_sql
entries.to_sql
BttUser.joins(:btt_notes).where.not(entries)
BttUser.joins(:btt_notes).to_sql
BttUser.joins(:notes).to_sql
BttUser.joins(:notes).where.not(entries)
BttUser.where.not(entries)
Issue.where.not(entries)
entries.to_sql
entries = BttNote.joins(:catalog).where(catalog: {id: 1}).select(:btt_id)
entries.to_sql
BttUser.where.not(BttNote.joins(:catalog).where(catalog: {id:1}))
BttUsere.where.not(BttNote.joins(:catalog).where(catalog: {id:1}))
BttUsere.where.not(BttNote.joins(:catalog).where(catalog: {id:1})
BttUser.where.not(entries).to_sql
User.where.not(entries).to_sql
entries.to_sql
entries = BttNote.joins(:catalog).where(catalog: {id: 1})
Notes
Note
entries = Note.joins(:catalog).where(catalog: {id: 1})
c
s
ActiveRecord::Base.connection.execute("DROP TABLE btt_notes, btt_users, btt_phones")
c
ActiveRecord::Base.connection.execute("DROP TABLE btt_notes, btt_users, btt_phones")
ActiveRecord::Base.connection.execute("DROP TABLE btt_notes, btt_users, btt_phones, catalogs")
c
CreateStoredFiltersTable.new.down
CreateStoredFiltersTable.new.up
CreateStoredFiltersTable.up
CreateStoredFiltersTable
CreatedStoredFiltersTable
c
Hammerstone::Refine::Stabilizers.CreateStoredFiltersTable.new.up
c
s
expected_sql
temp =  apply_condition_on_test_filter(condition_under_test, data).to_sql
